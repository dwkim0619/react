리액트 네이티브
    - 안드로이드, iOS 네이티브 앱 작성(크로스 플랫폼용)
      인앱 구매나 푸시 알림과 같이 플랫폼 종속적 기능은 별도 구현
    - readct-dom은 웹 개발시만 사용됨
    - 모바일에서 자바스크립트를 실행하기 위해 JavascriptCore를 사용
      JavascriptCore는 웹킷(Webkit)에 내장된 자바스크립트 엔진
    - virtual dom은 데이터 변경시 UI에 변경된 부분을 빨리 찾기 위해 사용되는 알고리즘

React.createElement(component, props, ...children)
    - component : 문자열(HTML Tag) 또는 React component    
    - props : component가 사용하는 데이터, 돔 요소인 경우 style, className 등
    - children : 해당 component가 감싸고 있는 내부 component
        <div>
            <p>hello</p>
            <p>world</p>
        </div>

        createElement(
            'div',
            null,
            createElement('p', null, 'hello'),
            createElement('p', null, 'world'),
        )
    - createElement 보다는 babel의 도움을 받아 JSX를 사용

babel
    - 자바스크립트 코드를 변환해 주는 컴파일러
      변환 작업은 plugin 단위로 이루어짐, 두 번의 변환이 필요하다면 두 개의 플러그인을 사용
      플러그인 집합을 preset이라 함

    - 최신의 문법을 지원하지 않는 환경에서도 최신의 문법 사용 가능
    - ES5 ==> ES6
    - 코드에서 주석 제거 및 압축
    - JSX 문법 사용(JSX ==> createElement)

웹팩
    - 자바스크립트로 만든 프로그램을 배포하기 좋은 형태로 묶어 주는 툴
    - ES6부터 모듈 시스템이 언어 차원에서 지원
    - 사용
        1. npm init -y  // package.json 생성
        2. npm install webpack webpack-cli react react-dom  // webpack 과 react 패키지 설치
        3. npx webpack



ESM(ES6 모듈 시스템)
    // file1.js
    export default function fun1() {}
    export function fun2() {}
    export const variable1 = 123;
    export let variable2 = 'hello';

    // file2.js
    import myFunc1, { fun2, variable1, variable2 } from './file1.js'

    // file3.js
    import { fun2 as myFunc2 } from './file1.js'

    - default 키워드는 한 파일에 한 번만 사용
    - default 키워드로 내보내진 코드는 괄호({})없이 가져올 수 있고,
      이름은 원하는 대로 지정 가능

Polyfill
    - 웹 브라우저상의 기능을 구현하는 플러그인
    - 실행 시점에 기능이 존재하는지 검사해서 그 기능이 없을 때만 주입하는 것

Sass(syntactically awesome stylesheets)
    - 순수 CSS 문법은 코드 재사용이 어려움
    - Sass에는 변수와 mixin 개념이 있어 중복 코드를 많이 줄임

리액트 프로그래밍 할 때는
    - 컴포넌트 중심으로 생각
    - UI는 컴포넌트 조합으로 표현
    - 컴포넌트는 여러 곳에 재사용하기 위해 
      서로 간의 의존성을 최소화하면서 내부적으로는 응집도(cohesion)를 높여야

단일 페이지 애플리케이션(single page application)
    - 최초 요청 시 서버에서 첫 페이지를 처리하고
      이후의 라우팅은 클라이언트에서 처리하는 웹 애플리케이션 방식
      페이지 전환에 의한 렌더링을 클라이언트에서 처리하기 때문에 
      마치 네이티브 애플리케이션처럼 자연스럽게 동작
    - 전통적인 방식의 웹 페이지는 
      페이지를 전환할 때마다 렌더링 결과를 서버에서 받기 때문에 화면이 깜빡이는 단점
    - 브라우저 history API : pushState, replaceState, onpopstate
